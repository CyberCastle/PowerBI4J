/*
 * Power BI Client
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package cl.cc.powerbi.client.model;

import java.util.Objects;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonValue;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

/**
 * The credential details
 */
@ApiModel(description = "The credential details")
@JsonPropertyOrder({ CredentialDetails.JSON_PROPERTY_CREDENTIALS, CredentialDetails.JSON_PROPERTY_CREDENTIAL_TYPE,
        CredentialDetails.JSON_PROPERTY_ENCRYPTED_CONNECTION, CredentialDetails.JSON_PROPERTY_ENCRYPTION_ALGORITHM,
        CredentialDetails.JSON_PROPERTY_PRIVACY_LEVEL, CredentialDetails.JSON_PROPERTY_USE_CALLER_A_A_D_IDENTITY,
        CredentialDetails.JSON_PROPERTY_USE_END_USER_O_AUTH2_CREDENTIALS })

public class CredentialDetails {
    public static final String JSON_PROPERTY_CREDENTIALS = "credentials";
    private String credentials;

    /**
     * The credential type
     */
    public enum CredentialTypeEnum {
        BASIC("Basic"),

        WINDOWS("Windows"),

        ANONYMOUS("Anonymous"),

        OAUTH2("OAuth2"),

        KEY("Key");

        private String value;

        CredentialTypeEnum(String value) {
            this.value = value;
        }

        @JsonValue
        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        @JsonCreator
        public static CredentialTypeEnum fromValue(String value) {
            for (CredentialTypeEnum b : CredentialTypeEnum.values()) {
                if (b.value.equals(value)) {
                    return b;
                }
            }
            throw new IllegalArgumentException("Unexpected value '" + value + "'");
        }
    }

    public static final String JSON_PROPERTY_CREDENTIAL_TYPE = "credentialType";
    private CredentialTypeEnum credentialType;

    /**
     * User input for this attribute is currently ignored. Today, regardless of the
     * provided value, we always try to establish an encrypted connection first but
     * fall back to an unencrypted option in case of a failure. &lt;br/&gt;This will
     * be fixed for the following data source types with the June 2019 gateway
     * release causing a value of Encrypted to try only an encrypted connection and
     * NotEncrypted with an unencrypted connection and there would be no fallback
     * behavior
     * &lt;ul&gt;&lt;li&gt;Impala&lt;/li&gt;&lt;li&gt;MySql&lt;/li&gt;&lt;li&gt;DB2&lt;/li&gt;&lt;li&gt;Netezza&lt;/li&gt;&lt;li&gt;PostgreSQL&lt;/li&gt;&lt;li&gt;Sybase&lt;/li&gt;&lt;li&gt;Teradata&lt;/li&gt;&lt;li&gt;GoogleBigQuery&lt;/li&gt;&lt;li&gt;Amazon
     * Redshift&lt;/li&gt;&lt;/ul&gt;
     */
    public enum EncryptedConnectionEnum {
        ENCRYPTED("Encrypted"),

        NOTENCRYPTED("NotEncrypted");

        private String value;

        EncryptedConnectionEnum(String value) {
            this.value = value;
        }

        @JsonValue
        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        @JsonCreator
        public static EncryptedConnectionEnum fromValue(String value) {
            for (EncryptedConnectionEnum b : EncryptedConnectionEnum.values()) {
                if (b.value.equals(value)) {
                    return b;
                }
            }
            throw new IllegalArgumentException("Unexpected value '" + value + "'");
        }
    }

    public static final String JSON_PROPERTY_ENCRYPTED_CONNECTION = "encryptedConnection";
    private EncryptedConnectionEnum encryptedConnection;

    /**
     * The encryption algorithm. For cloud datasource, use &#39;None&#39;. For
     * on-premises datasource, use gateway public key with &#39;RSA-OAEP&#39;
     * algorithm.
     */
    public enum EncryptionAlgorithmEnum {
        NONE("None"),

        RSA_OAEP("RSA-OAEP");

        private String value;

        EncryptionAlgorithmEnum(String value) {
            this.value = value;
        }

        @JsonValue
        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        @JsonCreator
        public static EncryptionAlgorithmEnum fromValue(String value) {
            for (EncryptionAlgorithmEnum b : EncryptionAlgorithmEnum.values()) {
                if (b.value.equals(value)) {
                    return b;
                }
            }
            throw new IllegalArgumentException("Unexpected value '" + value + "'");
        }
    }

    public static final String JSON_PROPERTY_ENCRYPTION_ALGORITHM = "encryptionAlgorithm";
    private EncryptionAlgorithmEnum encryptionAlgorithm;

    /**
     * The privacy level. Relevant when combining data from multiple sources.
     */
    public enum PrivacyLevelEnum {
        NONE("None"),

        PUBLIC("Public"),

        ORGANIZATIONAL("Organizational"),

        PRIVATE("Private");

        private String value;

        PrivacyLevelEnum(String value) {
            this.value = value;
        }

        @JsonValue
        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        @JsonCreator
        public static PrivacyLevelEnum fromValue(String value) {
            for (PrivacyLevelEnum b : PrivacyLevelEnum.values()) {
                if (b.value.equals(value)) {
                    return b;
                }
            }
            throw new IllegalArgumentException("Unexpected value '" + value + "'");
        }
    }

    public static final String JSON_PROPERTY_PRIVACY_LEVEL = "privacyLevel";
    private PrivacyLevelEnum privacyLevel;

    public static final String JSON_PROPERTY_USE_CALLER_A_A_D_IDENTITY = "useCallerAADIdentity";
    private Boolean useCallerAADIdentity;

    public static final String JSON_PROPERTY_USE_END_USER_O_AUTH2_CREDENTIALS = "useEndUserOAuth2Credentials";
    private Boolean useEndUserOAuth2Credentials;

    public CredentialDetails credentials(String credentials) {

        this.credentials = credentials;
        return this;
    }

    /**
     * The credentials. Depends on the &#39;credentialType&#39; value. See [Update
     * Datasource Examples](/rest/api/power-bi/gateways/updatedatasource#examples).
     * 
     * @return credentials
     **/
    @ApiModelProperty(required = true, value = "The credentials. Depends on the 'credentialType' value. See [Update Datasource Examples](/rest/api/power-bi/gateways/updatedatasource#examples).")
    @JsonProperty(JSON_PROPERTY_CREDENTIALS)
    @JsonInclude(value = JsonInclude.Include.ALWAYS)

    public String getCredentials() {
        return credentials;
    }

    public void setCredentials(String credentials) {
        this.credentials = credentials;
    }

    public CredentialDetails credentialType(CredentialTypeEnum credentialType) {

        this.credentialType = credentialType;
        return this;
    }

    /**
     * The credential type
     * 
     * @return credentialType
     **/
    @ApiModelProperty(required = true, value = "The credential type")
    @JsonProperty(JSON_PROPERTY_CREDENTIAL_TYPE)
    @JsonInclude(value = JsonInclude.Include.ALWAYS)

    public CredentialTypeEnum getCredentialType() {
        return credentialType;
    }

    public void setCredentialType(CredentialTypeEnum credentialType) {
        this.credentialType = credentialType;
    }

    public CredentialDetails encryptedConnection(EncryptedConnectionEnum encryptedConnection) {

        this.encryptedConnection = encryptedConnection;
        return this;
    }

    /**
     * User input for this attribute is currently ignored. Today, regardless of the
     * provided value, we always try to establish an encrypted connection first but
     * fall back to an unencrypted option in case of a failure. &lt;br/&gt;This will
     * be fixed for the following data source types with the June 2019 gateway
     * release causing a value of Encrypted to try only an encrypted connection and
     * NotEncrypted with an unencrypted connection and there would be no fallback
     * behavior
     * &lt;ul&gt;&lt;li&gt;Impala&lt;/li&gt;&lt;li&gt;MySql&lt;/li&gt;&lt;li&gt;DB2&lt;/li&gt;&lt;li&gt;Netezza&lt;/li&gt;&lt;li&gt;PostgreSQL&lt;/li&gt;&lt;li&gt;Sybase&lt;/li&gt;&lt;li&gt;Teradata&lt;/li&gt;&lt;li&gt;GoogleBigQuery&lt;/li&gt;&lt;li&gt;Amazon
     * Redshift&lt;/li&gt;&lt;/ul&gt;
     * 
     * @return encryptedConnection
     **/
    @ApiModelProperty(required = true, value = "User input for this attribute is currently ignored. Today, regardless of the provided value, we always try to establish an encrypted connection first but fall back to an unencrypted option in case of a failure. <br/>This will be fixed for the following data source types with the June 2019 gateway release causing a value of Encrypted to try only an encrypted connection and NotEncrypted with an unencrypted connection and there would be no fallback behavior <ul><li>Impala</li><li>MySql</li><li>DB2</li><li>Netezza</li><li>PostgreSQL</li><li>Sybase</li><li>Teradata</li><li>GoogleBigQuery</li><li>Amazon Redshift</li></ul>")
    @JsonProperty(JSON_PROPERTY_ENCRYPTED_CONNECTION)
    @JsonInclude(value = JsonInclude.Include.ALWAYS)

    public EncryptedConnectionEnum getEncryptedConnection() {
        return encryptedConnection;
    }

    public void setEncryptedConnection(EncryptedConnectionEnum encryptedConnection) {
        this.encryptedConnection = encryptedConnection;
    }

    public CredentialDetails encryptionAlgorithm(EncryptionAlgorithmEnum encryptionAlgorithm) {

        this.encryptionAlgorithm = encryptionAlgorithm;
        return this;
    }

    /**
     * The encryption algorithm. For cloud datasource, use &#39;None&#39;. For
     * on-premises datasource, use gateway public key with &#39;RSA-OAEP&#39;
     * algorithm.
     * 
     * @return encryptionAlgorithm
     **/
    @ApiModelProperty(required = true, value = "The encryption algorithm. For cloud datasource, use 'None'. For on-premises datasource, use gateway public key with 'RSA-OAEP' algorithm.")
    @JsonProperty(JSON_PROPERTY_ENCRYPTION_ALGORITHM)
    @JsonInclude(value = JsonInclude.Include.ALWAYS)

    public EncryptionAlgorithmEnum getEncryptionAlgorithm() {
        return encryptionAlgorithm;
    }

    public void setEncryptionAlgorithm(EncryptionAlgorithmEnum encryptionAlgorithm) {
        this.encryptionAlgorithm = encryptionAlgorithm;
    }

    public CredentialDetails privacyLevel(PrivacyLevelEnum privacyLevel) {

        this.privacyLevel = privacyLevel;
        return this;
    }

    /**
     * The privacy level. Relevant when combining data from multiple sources.
     * 
     * @return privacyLevel
     **/
    @ApiModelProperty(required = true, value = "The privacy level. Relevant when combining data from multiple sources.")
    @JsonProperty(JSON_PROPERTY_PRIVACY_LEVEL)
    @JsonInclude(value = JsonInclude.Include.ALWAYS)

    public PrivacyLevelEnum getPrivacyLevel() {
        return privacyLevel;
    }

    public void setPrivacyLevel(PrivacyLevelEnum privacyLevel) {
        this.privacyLevel = privacyLevel;
    }

    public CredentialDetails useCallerAADIdentity(Boolean useCallerAADIdentity) {

        this.useCallerAADIdentity = useCallerAADIdentity;
        return this;
    }

    /**
     * Should the caller&#39;s AAD identity be used for OAuth2 credentials
     * configuration
     * 
     * @return useCallerAADIdentity
     **/
    @javax.annotation.Nullable
    @ApiModelProperty(value = "Should the caller's AAD identity be used for OAuth2 credentials configuration")
    @JsonProperty(JSON_PROPERTY_USE_CALLER_A_A_D_IDENTITY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

    public Boolean getUseCallerAADIdentity() {
        return useCallerAADIdentity;
    }

    public void setUseCallerAADIdentity(Boolean useCallerAADIdentity) {
        this.useCallerAADIdentity = useCallerAADIdentity;
    }

    public CredentialDetails useEndUserOAuth2Credentials(Boolean useEndUserOAuth2Credentials) {

        this.useEndUserOAuth2Credentials = useEndUserOAuth2Credentials;
        return this;
    }

    /**
     * Should the end-user OAuth2 credentials be used for connecting to the
     * datasource in DirectQuery mode. Only supported for Direct Query to SQL Azure.
     * 
     * @return useEndUserOAuth2Credentials
     **/
    @javax.annotation.Nullable
    @ApiModelProperty(value = "Should the end-user OAuth2 credentials be used for connecting to the datasource in DirectQuery mode. Only supported for Direct Query to SQL Azure.")
    @JsonProperty(JSON_PROPERTY_USE_END_USER_O_AUTH2_CREDENTIALS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

    public Boolean getUseEndUserOAuth2Credentials() {
        return useEndUserOAuth2Credentials;
    }

    public void setUseEndUserOAuth2Credentials(Boolean useEndUserOAuth2Credentials) {
        this.useEndUserOAuth2Credentials = useEndUserOAuth2Credentials;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CredentialDetails credentialDetails = (CredentialDetails) o;
        return Objects.equals(this.credentials, credentialDetails.credentials)
                && Objects.equals(this.credentialType, credentialDetails.credentialType)
                && Objects.equals(this.encryptedConnection, credentialDetails.encryptedConnection)
                && Objects.equals(this.encryptionAlgorithm, credentialDetails.encryptionAlgorithm)
                && Objects.equals(this.privacyLevel, credentialDetails.privacyLevel)
                && Objects.equals(this.useCallerAADIdentity, credentialDetails.useCallerAADIdentity)
                && Objects.equals(this.useEndUserOAuth2Credentials, credentialDetails.useEndUserOAuth2Credentials);
    }

    @Override
    public int hashCode() {
        return Objects.hash(credentials, credentialType, encryptedConnection, encryptionAlgorithm, privacyLevel,
                useCallerAADIdentity, useEndUserOAuth2Credentials);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class CredentialDetails {\n");
        sb.append("    credentials: ").append(toIndentedString(credentials)).append("\n");
        sb.append("    credentialType: ").append(toIndentedString(credentialType)).append("\n");
        sb.append("    encryptedConnection: ").append(toIndentedString(encryptedConnection)).append("\n");
        sb.append("    encryptionAlgorithm: ").append(toIndentedString(encryptionAlgorithm)).append("\n");
        sb.append("    privacyLevel: ").append(toIndentedString(privacyLevel)).append("\n");
        sb.append("    useCallerAADIdentity: ").append(toIndentedString(useCallerAADIdentity)).append("\n");
        sb.append("    useEndUserOAuth2Credentials: ").append(toIndentedString(useEndUserOAuth2Credentials))
                .append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(java.lang.Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

}
